{
  "id": "code-13",
  "title": "Pseudocode Generator",
  "category": "coding",
  "goal": "Assist users in understanding and visualizing algorithms by converting them into clear step-by-step pseudocode.",
  "prompt": "Generate pseudocode for the following {algorithm} and clearly describe the step-by-step logic.",
  "variables": ["algorithm"],
  "tags": ["pseudocode","algorithms","coding","logic"],
  "models_tested": ["gpt-5","gemini-2.5","claude-3"],
  "responses": {
    "gpt-5": "# Merge Sort — pseudocode + step-by-step logic\n\nBelow is a clear, implementation-friendly pseudocode for the classic **recursive Merge Sort** and the `Merge` helper. After that I explain the algorithm step-by-step, show a worked example, list complexity and properties, and give a few practical implementation notes.\n\n---\n\n## Pseudocode\n\n```\n// Top-level entry: sorts array A in ascending order\nfunction MergeSort(A):\n    if length(A) ≤ 1:\n        return A                     // already sorted\n    mid ← floor(length(A) / 2)\n    left  ← MergeSort(A[0 .. mid-1])   // left half (0..mid-1)\n    right ← MergeSort(A[mid .. end])   // right half (mid..end)\n    return Merge(left, right)\n\n\n// Merge two sorted arrays L and R into one sorted array\nfunction Merge(L, R):\n    i ← 0       // index into L\n    j ← 0       // index into R\n    result ← empty array\n    while i < length(L) and j < length(R):\n        if L[i] ≤ R[j]:\n            append L[i] to result\n            i ← i + 1\n        else:\n            append R[j] to result\n            j ← j + 1\n    // one of L or R may still have elements — append them\n    while i < length(L):\n        append L[i] to result\n        i ← i + 1\n    while j < length(R):\n        append R[j] to result\n        j ← j + 1\n    return result\n```\n\n> Note: the pseudocode above uses array-slicing notation `A[a..b]` meaning elements from index `a` up to `b` inclusive (or adjust to your language’s conventions). The `≤` in `Merge` preserves stability (equal elements keep original left-first order).\n\n---\n\n## Step-by-step logic (plain English)\n\n1. **Divide**: If the array has 0 or 1 elements, it's already sorted — return it. Otherwise, split the array into two roughly equal halves (left and right).\n2. **Conquer**: Recursively sort the left half and recursively sort the right half. Each recursive call repeats step 1 until base cases (length 0 or 1) are reached.\n3. **Combine (Merge)**: You now have two sorted arrays (`left` and `right`). Merge them into a single sorted array by repeatedly taking the smaller of the two front elements and appending it to the result. When one side is exhausted, append the remaining elements from the other side.\n4. **Return**: The merged array is a sorted version of the input array. The recursion unwinds, merging larger and larger subarrays until the top-level call returns the fully sorted array.\n\nThe algorithm follows the classic *divide and conquer* pattern: break the problem into subproblems, solve each recursively, then combine solutions.\n\n---\n\n## Worked example\n\nSort A = [38, 27, 43, 3, 9, 82, 10]\n\n1. Split into [38,27,43] and [3,9,82,10].\n2. Sort left [38,27,43]:\n   - Split into [38] and [27,43]\n   - [38] base case → [38]\n   - Sort [27,43]: split into [27] and [43] → merge → [27,43]\n   - Merge [38] and [27,43] → [27,38,43]\n3. Sort right [3,9,82,10]:\n   - Split into [3,9] and [82,10]\n   - Sort [3,9] → [3,9]\n   - Sort [82,10] → [10,82]\n   - Merge [3,9] and [10,82] → [3,9,10,82]\n4. Merge [27,38,43] and [3,9,10,82] → [3,9,10,27,38,43,82]\n\n---\n\n## Complexity & properties\n\n- Time complexity: Best / Average / Worst: **O(n log n)**.\n- Space complexity: Typical top-down implementation: **O(n)** auxiliary space.\n- Stability: The Merge implementation above is **stable** (preserves original order for equal elements).\n- Parallelism: MergeSort is readily parallelizable.\n\n---\n\n## Practical implementation notes / gotchas\n\n- Use `mid = start + (end - start) // 2` to avoid overflow in languages where that matters.\n- For small subarrays (e.g., length ≤ 16), insertion sort can be faster in practice.\n- To reduce memory, implement bottom-up merge sort with a reusable auxiliary buffer.\n- Preserve stability by preferring elements from the left subarray when values are equal (`≤`).\n\n---\n\nIf you want, I can:\n- give an index-based in-place-ish version (top-down using a single temp buffer),\n- show iterative (bottom-up) mergesort pseudocode, or\n- convert this pseudocode into a real implementation in a language you choose (Python/Java/JS/C++). Which would you like next?",
    "gemini-2.5": "Mergesort is a classic divide-and-conquer algorithm. Here is a compact, index-based pseudocode plus a clear step-by-step explanation.\n\n---\n\n## Pseudocode (index-based)\n\n```\nFUNCTION MERGESORT(A, p, r):\n    IF p < r THEN\n        q = FLOOR((p + r) / 2)\n        MERGESORT(A, p, q)\n        MERGESORT(A, q + 1, r)\n        MERGE(A, p, q, r)\n    END IF\nEND FUNCTION\n\nFUNCTION MERGE(A, p, q, r):\n    n1 = q - p + 1\n    n2 = r - q\n    CREATE ARRAY L[1...n1]\n    CREATE ARRAY R[1...n2]\n    FOR i = 1 TO n1:\n        L[i] = A[p + i - 1]\n    FOR j = 1 TO n2:\n        R[j] = A[q + j]\n    L[n1 + 1] = INFINITY\n    R[n2 + 1] = INFINITY\n    i = 1\n    j = 1\n    FOR k = p TO r:\n        IF L[i] <= R[j] THEN\n            A[k] = L[i]\n            i = i + 1\n        ELSE\n            A[k] = R[j]\n            j = j + 1\n        END IF\n    END FOR\nEND FUNCTION\n```\n\n---\n\n## Step-by-step logic\n\n1. **Base case:** If the subarray length is 0 or 1, it is already sorted.\n2. **Split:** Compute midpoint `q` and recursively sort left (`p..q`) and right (`q+1..r`).\n3. **Merge:** Use temporary arrays (with sentinels or checks) to merge the two sorted halves into a single sorted range `p..r`.\n\nWould you like a worked example or a language-specific implementation?",
    "claude-3": "# Mergesort Algorithm - Pseudocode and Logic\n\n## Pseudocode\n\n```\nfunction mergeSort(array, left, right)\n    if left < right\n        mid = floor((left + right) / 2)\n        mergeSort(array, left, mid)\n        mergeSort(array, mid + 1, right)\n        merge(array, left, mid, right)\n    end if\nend function\n\nfunction merge(array, left, mid, right)\n    leftArray = array[left...mid]\n    rightArray = array[mid+1...right]\n    i = 0\n    j = 0\n    k = left\n    while i < length(leftArray) AND j < length(rightArray)\n        if leftArray[i] <= rightArray[j]\n            array[k] = leftArray[i]\n            i = i + 1\n        else\n            array[k] = rightArray[j]\n            j = j + 1\n        end if\n        k = k + 1\n    end while\n    while i < length(leftArray)\n        array[k] = leftArray[i]\n        i = i + 1\n        k = k + 1\n    end while\n    while j < length(rightArray)\n        array[k] = rightArray[j]\n        j = j + 1\n        k = k + 1\n    end while\nend function\n```\n\n## Step-by-step Logic\n\n- **Divide:** Recursively split the array until subarrays of length 1.\n- **Conquer:** Merge adjacent sorted subarrays using two-pointer comparisons.\n- **Time Complexity:** O(n log n)\n- **Space Complexity:** O(n)\n- **Stable:** Yes (use <= when comparing to prefer left side).\n"
  },
  "last_updated": "2025-11-01"
}
