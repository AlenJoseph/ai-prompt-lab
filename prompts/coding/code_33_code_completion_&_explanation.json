{
  "id": "code-33",
  "title": "Code Completion & Explanation",
  "category": "coding",
  "goal": "Complete incomplete code to satisfy task requirements and include line-by-line explanations",
  "prompt": "You are a senior developer and reviewer. The code given below is incomplete {code}. Complete it to fulfill the {task} requirements and include line by line explanation.",
  "variables": ["task", "code"],
  "tags": ["code-completion", "code-explanation", "programming"],
  "models_tested": ["gpt-5", "gemini-2.5", "claude-3"],
  "responses": {
    "gpt-5": "# Completed `two_sum` implementation (with example and explanation)\n\n```python\nfrom typing import List, Tuple\n\ndef two_sum(nums: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Return indices of the two numbers in `nums` that add up to `target`.\n    Assumes exactly one solution exists and you may not use the same element twice.\n    \"\"\"\n\n    # A dictionary mapping number -> its index seen so far.\n    seen = {}\n\n    # Iterate over the array once.\n    for i, num in enumerate(nums):\n        # Compute the complement that would sum with current num to reach target.\n        complement = target - num\n\n        # If complement was seen earlier, return indices (earlier_index, current_index).\n        if complement in seen:\n            return (seen[complement], i)\n\n        # Otherwise store the current number with its index for future complements to use.\n        seen[num] = i\n\n    # By problem assumption we should never reach here because exactly one solution exists.\n    raise ValueError(\"No two sum solution\")\n```\n\n# Line-by-line explanation\n\n1. `from typing import List, Tuple`\n   * Import type hints for clearer function signature (optional but helps readability).\n2. `def two_sum(nums: List[int], target: int) -> Tuple[int, int]:`\n   * Define the function accepting a list of integers and a target integer; returns a tuple of two indices.\n3. `\"\"\" ... \"\"\"`\n   * Docstring describing behavior and assumptions.\n4. `seen = {}`\n   * Create an empty dictionary (`seen`) that will map numbers we've encountered to their indices.\n5. `for i, num in enumerate(nums):`\n   * Loop over the list with `enumerate` so we have both the index `i` and value `num`.\n6. `complement = target - num`\n   * For the current number, compute the complement required to reach the target.\n7. `if complement in seen:`\n   * Check if that complement was already encountered earlier in the array.\n8. `return (seen[complement], i)`\n   * If yes, return the stored index of the complement and the current index — that pair sums to `target`.\n9. `seen[num] = i`\n   * If complement wasn't seen, store the current number with its index so future elements can match with it.\n10. `raise ValueError(\"No two sum solution\")`\n   * Defensive: if the loop finishes without finding a pair, raise an error. (Under the problem's assumption this shouldn't happen.)\n\n# Complexity\n* Time: O(n) — single pass through the list.\n* Space: O(n) — in worst case we store every element in `seen`.\n\n# Example usage\n\n```python\nif __name__ == \"__main__\":\n    print(two_sum([2, 7, 11, 15], 9))   # -> (0, 1)\n    print(two_sum([3, 2, 4], 6))        # -> (1, 2)\n```",
    "gemini-2.5": "Here is the completed Python code for the `two_sum` function with an efficient O(n) hash map approach.\n\n```python\ndef two_sum(nums, target):\n    complement_map = {}  # key: number, value: index\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\n    # Should not be reached if one solution is guaranteed\n    raise ValueError(\"No valid pair found\")\n```\n\n### Line-by-Line Explanation\n1. Define `two_sum` with parameters `nums` and `target`.\n2. Initialize `complement_map` — a dictionary storing each number's index.\n3. Iterate over the list with both index (`i`) and value (`num`).\n4. Compute `complement = target - num` — the number we need to reach the target.\n5. Check if `complement` is already in `complement_map`.\n6. If yes, return the indices `[complement_map[complement], i]`.\n7. Otherwise, add `num` and its index to the map.\n8. If no pair is found (though guaranteed), raise a `ValueError`.\n\n### Example\n```python\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\n```",
    "claude-3": "def two_sum(nums, target):\n    \"\"\"Find the indices of two numbers that add up to target.\"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    raise ValueError(\"No solution found\")\n\n# Example usage\nprint(two_sum([2, 7, 11, 15], 9))  # [0, 1]\nprint(two_sum([3, 2, 4], 6))      # [1, 2]\n"
  },
  "last_updated": "2025-11-03"
}
